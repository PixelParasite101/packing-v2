<!DOCTYPE html>
<html lang="da">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rund Tank – 2D fysik packer</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#0f141b99; --accent:#7cc4ff; --text:#e6eef7; --muted:#9fb3c8; --chip:#111926b3; --ok:#5dd39e; --warn:#ffd166; --err:#ff6b6b;
      --glass-blur:14px; --glass-bright:1.15; --radius:18px; --shadow:0 10px 30px #0009;
    }
    html,body{height:100%}
    *{box-sizing:border-box}
    body{margin:0;background:radial-gradient(1200px 1200px at 80% -10%, #14202f 0%, var(--bg) 55%);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}

    #stage{position:fixed;inset:0}

    /* Glass panel */
    #panelToggle{position:fixed;left:12px;top:12px;z-index:5;background:#0d1522cc;border:1px solid #1c2b42;backdrop-filter:blur(var(--glass-blur)) brightness(var(--glass-bright));padding:8px 10px;border-radius:12px;cursor:pointer;box-shadow:var(--shadow)}
    #panelToggle:hover{filter:brightness(1.15)}
    #panel{position:fixed;left:12px;top:56px;bottom:12px;width:360px;z-index:4;display:flex;flex-direction:column;gap:10px;padding:14px 14px 18px 14px;border:1px solid #1c2b42;border-radius:var(--radius);background:var(--panel);backdrop-filter:blur(var(--glass-blur)) brightness(var(--glass-bright));box-shadow:var(--shadow);overflow:auto}
    #panel h3{margin:8px 0 6px 0;color:#cfe6ff;font-weight:600;font-size:14px;letter-spacing:.2px}
    fieldset{border:1px solid #1b2b41;border-radius:12px;padding:10px;margin:0}
    fieldset legend{padding:0 6px;color:#c2d7f2}
    label{display:flex;align-items:center;justify-content:space-between;gap:8px;margin:6px 0;font-size:13px;color:var(--muted)}
    label > span{flex:1}
    input[type="number"],input[type="text"],select{flex:0 0 110px;background:#0b1220;border:1px solid #1b2b41;border-radius:10px;color:var(--text);padding:6px 8px;outline:none}
    input[type="checkbox"]{transform:translateY(1px)}
    .row{display:flex;gap:8px;align-items:center}
    .row > *{flex:1}
    button{background:#122036;color:#daf0ff;border:1px solid #1b2b41;border-radius:12px;padding:8px 10px;font-size:13px;cursor:pointer}
    button:hover{filter:brightness(1.12)}
    button.secondary{background:#0b1220}
    button.danger{background:#2a1218;border-color:#4c1b25;color:#ffd7d7}
    .split{display:grid;grid-template-columns:1fr 1fr;gap:8px}

    /* HUD chips */
    #hud{position:fixed;right:12px;top:12px;display:flex;gap:8px;z-index:3}
    .chip{background:var(--chip);padding:8px 10px;border:1px solid #1b2b41;border-radius:999px;font-size:12px;backdrop-filter:blur(10px) brightness(1.1)}

    /* Hints */
    #hints{position:fixed;left:0;right:0;bottom:0;text-align:center;padding:10px 16px;color:#b7c9de;background:linear-gradient(180deg, transparent, #0b0f1480 30%, #0b0f14 100%);z-index:2;font-size:12px}

    canvas{display:block}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  @media (max-width: 420px){
      #panel{width:calc(100% - 24px);left:12px;right:12px}
      input[type="number"],input[type="text"],select{flex:0 0 130px}
    }
  </style>
</head>
<body>
  <div id="stage" aria-label="Simulations-canvas"></div>

  <button id="panelToggle" title="Vis/skjul panel (H)">☰</button>

  <aside id="panel" role="region" aria-label="Kontrolpanel">
    <h3>Tank & skalering</h3>
    <fieldset>
      <label><span>Tank Ø (mm)</span><input id="tankMm" type="number" min="100" step="10" /></label>
      <label><span>Indre kerne Ø (mm)</span><input id="coreMm" type="number" min="0" step="5" /></label>
    </fieldset>

    <h3>Rack størrelse</h3>
    <fieldset>
      <div class="row"><label><span>Bredde B (mm)</span><input id="rackB" type="number" min="5" step="1" /></label></div>
      <div class="row"><label><span>Længde L (mm)</span><input id="rackL" type="number" min="5" step="1" /></label></div>
      <label><span>Tilfældig rotation</span><input id="randRot" type="checkbox" /></label>
      <label><span>Tilfældig position</span><input id="randPos" type="checkbox" /></label>
    </fieldset>

    <h3>Orientering</h3>
    <fieldset>
      <label><span>Snap-interval</span>
        <select id="snapStep">
          <option value="0">Fra</option>
          <option value="15">15°</option>
          <option value="30">30°</option>
          <option value="45">45°</option>
          <option value="90">90°</option>
        </select>
      </label>
      <label title="Komma-separeret – fx 0,45,90"><span>Tilladte vinkler (°)</span><input id="allowedAngles" type="text" placeholder="fx 0,45,90" /></label>
      <label><span>Lås orientering</span><input id="lockRot" type="checkbox" /></label>
      <div class="split">
        <button id="snapAll">Snap alle</button>
        <button id="rebuild">Genopbyg</button>
      </div>
    </fieldset>

    <h3>Vægge & radial kraft</h3>
    <fieldset>
      <label><span>Hård ydervæg (segments)</span><input id="hardOuter" type="checkbox" /></label>
      <div class="row"><label><span>Kraft mod ydervæg</span><input id="forceOuterOn" type="checkbox" /></label><input id="forceOuter" type="number" min="0" max="0.01" step="0.0005" /></div>
      <div class="row"><label><span>Kraft mod kerne</span><input id="forceInnerOn" type="checkbox" /></label><input id="forceInner" type="number" min="0" max="0.01" step="0.0005" /></div>
    </fieldset>

    <h3>Elasticitet (restitution)</h3>
    <fieldset>
      <label><span>Rack ↔ rack</span><input id="restRackRack" type="number" min="0" max="1" step="0.05" /></label>
      <label><span>Rack ↔ vægge/kerne</span><input id="restRackWalls" type="number" min="0" max="1" step="0.05" /></label>
      <label title="Når segmentring er slået fra"><span>Ydervæg (fallback)</span><input id="restOuter" type="number" min="0" max="1" step="0.05" /></label>
    </fieldset>

    <h3>Vægge (radiale)</h3>
    <fieldset>
      <label><span>Vinkel (°)</span><input id="radialDeg" type="number" step="1" /></label>
      <label><span>Tykkelse (mm)</span><input id="radialThkMm" type="number" min="1" step="1" /></label>
      <div class="split"><button id="addWall">+ Væg</button><button id="clearWalls" class="secondary">Ryd vægge</button></div>
    </fieldset>

    <h3>Layout</h3>
    <fieldset>
      <div class="split"><button id="addRack">+ Rack</button><button id="add10">+ 10</button></div>
      <div class="split"><button id="clearRacks" class="secondary">Ryd racks</button><button id="deleteSelected" class="danger">Slet valgt</button></div>
      <div class="split"><button id="saveLayout">Gem layout</button><button id="loadLayout" class="secondary">Indlæs layout</button></div>
      <div class="split"><button id="deleteOverlaps" class="danger">Slet overlaps</button><button id="runTests">Kør tests</button></div>
    </fieldset>

    <h3>Avanceret</h3>
    <fieldset>
      <label title="Antal segmenter i ydervæggen"><span>Ring-segmenter</span><input id="ringSegments" type="number" min="16" max="256" step="1" /></label>
      <label title="Tykkelse i pixels"><span>Ring-tykkelse (px)</span><input id="ringThkPx" type="number" min="2" max="40" step="1" /></label>
      <label title="Global angular damping"><span>Angular damping</span><input id="angDamp" type="number" min="0" max="0.2" step="0.005" /></label>
    </fieldset>

    <small style="opacity:.7">Indstillinger gemmes automatisk (key: <code>tankpacker.settings.v6</code>).</small>
  </aside>

  <div id="hud" aria-live="polite">
    <div class="chip">Racks: <span id="hudCount">0</span></div>
    <div class="chip">Fyldningsgrad: <span id="hudFill">0%</span></div>
    <div class="chip">Skala: <span id="hudScale">–</span></div>
  </div>

  <div id="hints">Klik: placér / vælg · <b>Drag</b>: træk rack · Q/E: roter ±snap · R: +90° · Delete: slet · Esc: fravælg · Space: pause/play · G: tyngdekraft · H: vis/skjul menu · T: tests</div>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
  <script>
  (function(){
    // -------- Pixel ratio and Matter refs --------
    const PR = Math.min(window.devicePixelRatio||1, 2);
    const { Engine, Render, Runner, Bodies, Body, Composite, Events, Vector, SAT, Query, Mouse, MouseConstraint } = Matter;

    // ---------------- State & Persistence -----------------
    const SETTINGS_KEY = 'tankpacker.settings.v6';
    let state = {
      tankMm: 700,
      coreMm: 0,
      rackB: 50,
      rackL: 150,
      randRot: true,
      randPos: true,
      snapStep: 0, // degrees
      allowedAngles: '',
      lockRot: false,
      hardOuter: true,
      forceOuterOn: false,
      forceOuter: 0.002,
      forceInnerOn: false,
      forceInner: 0.0,
      restRackRack: 0.6,
      restRackWalls: 0.6,
      restOuter: 0.6,
      radialDeg: 0,
      radialThkMm: 6,
      ringSegments: 96,
      ringThkPx: 8,
      angDamp: 0.01,
      panelHidden: false
    };
    function saveSettings(){ try{ localStorage.setItem(SETTINGS_KEY, JSON.stringify(state)); }catch(e){} }
    function loadSettings(){ try{ const s=JSON.parse(localStorage.getItem(SETTINGS_KEY)||'{}'); Object.assign(state, s||{});}catch(e){} }
    loadSettings();

    // ---------------- DOM refs -----------------
    const el = (id)=>document.getElementById(id);
    const stage = el('stage');
    const hudCount = el('hudCount');
    const hudFill = el('hudFill');
    const hudScale = el('hudScale');

    const inputs = {
      tankMm: el('tankMm'), coreMm: el('coreMm'), rackB: el('rackB'), rackL: el('rackL'), randRot: el('randRot'), randPos: el('randPos'),
      snapStep: el('snapStep'), allowedAngles: el('allowedAngles'), lockRot: el('lockRot'),
      hardOuter: el('hardOuter'), forceOuterOn: el('forceOuterOn'), forceOuter: el('forceOuter'), forceInnerOn: el('forceInnerOn'), forceInner: el('forceInner'),
      restRackRack: el('restRackRack'), restRackWalls: el('restRackWalls'), restOuter: el('restOuter'),
      radialDeg: el('radialDeg'), radialThkMm: el('radialThkMm'),
      ringSegments: el('ringSegments'), ringThkPx: el('ringThkPx'), angDamp: el('angDamp')
    };

    // Init inputs from state
    for(const [k,inp] of Object.entries(inputs)){
      const v = state[k];
      if(inp.type==='checkbox') inp.checked=!!v; else inp.value = v;
      inp.addEventListener('input', ()=>{
        state[k] = (inp.type==='checkbox')? inp.checked : (inp.type==='number'? Number(inp.value) : inp.value);
        saveSettings();
        if(k==='tankMm'||k==='coreMm'||k==='ringSegments'||k==='ringThkPx'||k==='hardOuter') rebuildTank();
        if(k==='restRackRack'||k==='restRackWalls') applyRestitutionAll();
        if(k==='angDamp') applyAngularDampingAll();
        if(k==='lockRot') applyOrientationLockAll();
      });
    }

    // Panel toggle
    const panel = el('panel');
    const panelToggle = el('panelToggle');
    function applyPanelVisibility(){ panel.style.display = state.panelHidden? 'none':'flex'; }
    applyPanelVisibility();
    panelToggle.addEventListener('click', ()=>{ state.panelHidden=!state.panelHidden; applyPanelVisibility(); saveSettings(); });

    // ---------------- Matter setup -----------------
    const engine = Engine.create({ enableSleeping:true });
    engine.world.gravity.y = 0; // removed default downward gravity // default
    const render = Render.create({
      element: stage,
      engine,
      options:{ width: window.innerWidth, height: window.innerHeight, wireframes:false, background:'transparent', pixelRatio:PR }
    });
    const runner = Runner.create();
    Render.run(render); Runner.run(runner, engine);

    // Mouse (for pointer pos; dragging disabled)
    const mouse = Mouse.create(render.canvas);
    // Fix drag-offset when using high-DPI / custom pixelRatio
    // Use pixelRatio only (no extra scale), otherwise the mouse gets over-scaled
    if (typeof mouse.pixelRatio !== 'undefined') { mouse.pixelRatio = PR; }
    if (Mouse.setScale) { Mouse.setScale(mouse, { x: 1, y: 1 }); }
    const mouseConstraint = MouseConstraint.create(engine, { mouse, constraint: { stiffness: 0.18, angularStiffness: 0.8, render: { visible: false } } });
    Composite.add(engine.world, mouseConstraint);

    // Allow dragging only for racks
    Events.on(mouseConstraint, 'startdrag', (e)=>{
      if(!e.body || e.body.label !== 'rack'){
        mouseConstraint.body = null; // cancel drag for non-racks
        dragState.body = null; dragState.invalid = false; return;
      }
      selected = e.body;
      dragState.body = e.body;
      dragState.lastPos = Vector.clone(e.body.position);
      dragState.lastAngle = e.body.angle;
      dragState.invalid = false;
    });
    Events.on(mouseConstraint, 'enddrag', (e)=>{
      if(e.body && state.lockRot){ Body.setAngularVelocity(e.body,0); }
      if (dragState.body) {
        if (dragState.invalid) {
          // Revert to last valid placement
          Body.setPosition(dragState.body, dragState.lastPos);
          Body.setAngle(dragState.body, dragState.lastAngle);
          Body.setVelocity(dragState.body, {x:0,y:0});
          Body.setAngularVelocity(dragState.body, 0);
        }
        dragState.body = null; dragState.invalid = false;
      }
    });

    // World containers
    const world = engine.world;
    let racks = []; // dynamic rectangles
    let statics = []; // core + ring + radial walls
    let ringSegmentsBodies = [];
    let radialWalls = [];
    let coreBody = null;

    // Geometry / scale
    let center = { x: window.innerWidth/2, y: window.innerHeight/2 };
    let tankRadiusPx = 300;
    let pxPerMm = 1; // computed from tank size

    // Selection / hover
    let selected = null; let hoverBody = null; let lastPlaced = null;
    let dragState = { body: null, lastPos: null, lastAngle: 0, invalid: false };

    // -------- Utilities (use function decl. so they're hoisted) --------
    function toRad(deg){ return deg*Math.PI/180; }
    function toDeg(rad){ return rad*180/Math.PI; }
    function mm2px(mm){ return mm*pxPerMm; } // <— FIX: ensure defined & hoisted
    function px2mm(px){ return px/pxPerMm; }
    function bodyDimsPx(b){ return { w: b.bounds.max.x - b.bounds.min.x, h: b.bounds.max.y - b.bounds.min.y } }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    function allowedAnglesList(){
      const s = (state.allowedAngles||'').trim();
      if(!s) return null;
      const arr = s.split(',').map(x=>Number(x.trim())).filter(n=>Number.isFinite(n)).map(toRad).map(wrapAngle);
      const uniq = Array.from(new Set(arr.map(n=>Number(n.toFixed(6))))).map(n=>n);
      return uniq.sort((a,b)=>a-b);
    }
    function wrapAngle(a){ const t = (a % (2*Math.PI) + 2*Math.PI)%(2*Math.PI); return t; }

    function snapAngleRad(a){
      const list = allowedAnglesList();
      if(list && list.length){
        let best=list[0],bd=1e9; const aa = wrapAngle(a);
        for(const x of list){ const d = Math.min(Math.abs(aa-x), 2*Math.PI-Math.abs(aa-x)); if(d<bd){bd=d;best=x;} }
        return best;
      }
      const stepDeg = Number(state.snapStep)||0; if(stepDeg>0){ const step = toRad(stepDeg); return Math.round(wrapAngle(a)/step)*step; }
      return a;
    }

    function setAngleSnapped(b, a){ Body.setAngle(b, snapAngleRad(a)); }

    function safeCollided(A,B){ try{ const res = SAT.collides(A,B); return !!(res && res.collided); }catch(e){ return false; } }

    function anyVertexOutsideTank(body, tol=0.5){ const R = tankRadiusPx; for(const v of body.vertices){ const dx=v.x-center.x, dy=v.y-center.y; if(Math.hypot(dx,dy) > R + tol) return true; } return false; }

    function intersectsStatics(body){ for(const s of statics){ if(Query.region([s], body.bounds).length===0) continue; if(safeCollided(body, s)) return true; } return false; }

    function intersectsRacks(body, skip=null){ for(const o of racks){ if(o===skip) continue; if(Query.region([o], body.bounds).length===0) continue; if(safeCollided(body,o)) return true; } return false; }

    function violatesRules(body){
      if(anyVertexOutsideTank(body, 0.5)) return true;
      if(intersectsStatics(body)) return true;
      if(intersectsRacks(body, body)) return true;
      return false;
    }

    // -------- Resize & scale --------
    function resize(){
      const w = window.innerWidth, h = window.innerHeight;
      render.canvas.width = w*PR; render.canvas.height = h*PR; render.canvas.style.width=w+'px'; render.canvas.style.height=h+'px';
      render.options.width = w; render.options.height = h; center = {x:w/2, y:h/2};
      const margin = 40; tankRadiusPx = Math.max(50, Math.min(w, h)/2 - margin);
      pxPerMm = (tankRadiusPx*2)/Math.max(1, state.tankMm);
      hudScale.textContent = `1 mm → ${pxPerMm.toFixed(2)} px`;
      rebuildTank();
    }
    window.addEventListener('resize', resize); resize();

    // -------- Build statics --------
    function clearStatics(){
      for(const s of statics) Composite.remove(world, s);
      statics.length = 0; ringSegmentsBodies.length=0; radialWalls.length=0; coreBody=null;
    }

    function rebuildTank(){
      clearStatics();
      // Core
      const coreR = mm2px(state.coreMm/2);
      if(coreR>0){
        coreBody = Bodies.circle(center.x, center.y, coreR, { isStatic:true, label:'core', restitution: state.restRackWalls, render:{ fillStyle:'transparent', strokeStyle:'#335', lineWidth:1 }});
        Composite.add(world, coreBody); statics.push(coreBody);
      }
      // Outer ring segments
      if(state.hardOuter){ buildOuterRingSegments(state.ringSegments, state.ringThkPx); }
      applyRestitutionAll();
    }

    function buildOuterRingSegments(N=96, thick=8){
      ringSegmentsBodies.length=0;
      const R = tankRadiusPx - thick/2; const L = 2*Math.PI*R/N + 2; // +2 overlap
      for(let i=0;i<N;i++){
        const ang = i*(2*Math.PI/N);
        const cx = center.x + R*Math.cos(ang);
        const cy = center.y + R*Math.sin(ang);
        const seg = Bodies.rectangle(cx, cy, L, thick, { isStatic:true, angle:ang, label:'ring', restitution: state.restRackWalls, render:{ visible:false } });
        ringSegmentsBodies.push(seg); statics.push(seg);
      }
      Composite.add(world, ringSegmentsBodies);
    }

    function addRadialWall(angleDeg, thkMm){
      const ang = toRad(angleDeg);
      const len = tankRadiusPx*2; const thk = mm2px(thkMm);
      const wall = Bodies.rectangle(center.x, center.y, thk, len, { isStatic:true, angle: ang, label:'radial', restitution: state.restRackWalls, render:{ fillStyle:'transparent', strokeStyle:'#335', lineWidth:1 }});
      radialWalls.push(wall); statics.push(wall); Composite.add(world, wall);
    }

    // -------- Dynamic racks helpers --------
    function addRackAt(x,y){
      const angle = state.randRot? Math.random()*Math.PI*2 : 0;
      let body = state.randPos? spiralTryPlace(x,y) : (placeAdjacentTo(lastPlaced) || spiralTryPlace(x,y));
      if(!body) return null;
      body.plugin = body.plugin||{}; body.plugin.mm = { B: state.rackB, L: state.rackL };
      body.restitution = clamp(state.restRackRack,0,1); body.frictionAir = clamp(state.angDamp*0.5,0,0.5); body.friction = 0.1; body.frictionStatic = 0.5;
      if(state.lockRot){ Body.setAngularVelocity(body, 0); Body.setInertia(body, Infinity); }
      Composite.add(world, body); racks.push(body); lastPlaced = body; return body;
    }

    function removeRack(b){ Composite.remove(world, b); racks = racks.filter(x=>x!==b); if(selected===b) selected=null; }

    function clearRacks(){ for(const r of racks) Composite.remove(world, r); racks.length=0; selected=null; lastPlaced=null; }

    function applyRestitutionAll(){ for(const r of racks) r.restitution = clamp(state.restRackRack,0,1); for(const s of statics){ s.restitution = clamp(state.restRackWalls,0,1);} }

    function applyAngularDampingAll(){ for(const r of racks){ r.frictionAir = clamp(state.angDamp*0.5, 0, 0.5); } }

    function applyOrientationLockAll(){ for(const r of racks){ if(state.lockRot){ Body.setAngularVelocity(r,0); Body.setInertia(r, Infinity);} else { const dims=bodyDimsPx(r); const m = r.mass||1; const I = (m*(dims.w*dims.w + dims.h*dims.h))/12; Body.setInertia(r, I); } } }

    function snapAll(){ for(const r of racks){ setAngleSnapped(r, r.angle); if(state.lockRot){ Body.setAngularVelocity(r,0);} } }

    // -------- Placement with validation --------
    function tryPlaceAt(px, py, angleRad){
      const w = mm2px(state.rackB), h = mm2px(state.rackL);
      const a = (state.randRot? (Math.random()*Math.PI*2) : (angleRad||0));
      let ang = snapAngleRad(a);
      const body = Bodies.rectangle(px, py, w, h, {
        label:'rack',
        restitution: state.restRackRack,
        friction: 0.1,
        frictionStatic: 0.5,
        frictionAir: state.angDamp*0.5,
        chamfer: { radius: Math.min(w,h) * 0.08 },
        render: {
          fillStyle: 'rgba(18,32,54,0.60)',
          strokeStyle: '#2e4363',
          lineWidth: 1.5,
          opacity: 0.95
        }
      });
      Body.setAngle(body, ang);
      if(state.lockRot){ Body.setAngularVelocity(body, 0); Body.setInertia(body, Infinity); }
      if(anyVertexOutsideTank(body) || intersectsStatics(body) || intersectsRacks(body)) return null;
      return body;
    }

    function spiralTryPlace(px, py){
      const baseAng = state.randRot? Math.random()*Math.PI*2 : 0;
      const first = tryPlaceAt(px, py, baseAng); if(first) return first;
      const maxR = 120; const stepR = 6; const stepA = Math.PI/8;
      for(let r=stepR; r<=maxR; r+=stepR){
        for(let th=0; th<2*Math.PI; th+=stepA){
          const b = tryPlaceAt(px + r*Math.cos(th), py + r*Math.sin(th), baseAng);
          if(b) return b;
        }
      }
      return null;
    }

    function placeAdjacentTo(last){
      if(!last) return null;
      const dims = bodyDimsPx(last); const diag = Math.hypot(dims.w, dims.h);
      const dist = diag*0.5 + 8; // px gap
      const dirs = [ [1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1] ];
      for(const [dx,dy] of dirs){
        const b = spiralTryPlace(last.position.x + dx*dist, last.position.y + dy*dist);
        if(b) return b;
      }
      return null;
    }

    // -------- Fallback reflection (no ring) & forces --------
    function reflectIfOut(b){ if(state.hardOuter) return; const R = tankRadiusPx; let out=false; let n={x:0,y:0}; let maxd=0; for(const v of b.vertices){ const dx=v.x-center.x, dy=v.y-center.y; const d = Math.hypot(dx,dy)-R; if(d>0.5 && d>maxd){ out=true; maxd=d; n = Vector.normalise({x:dx,y:dy}); } }
      if(!out) return; // push inwards and reflect velocity if moving outward
      Body.translate(b, Vector.mult(n, -(maxd+1)));
      const v = b.velocity; const dot = v.x*n.x + v.y*n.y; if(dot>0){ const e = clamp(state.restOuter,0,1); const vprime = { x: v.x - (1+e)*dot*n.x, y: v.y - (1+e)*dot*n.y }; Body.setVelocity(b, vprime); }
    }

    function applyRadialForces(){
      if(!(state.forceOuterOn||state.forceInnerOn)) return;
      for(const b of racks){
        const dir = Vector.normalise({ x: b.position.x - center.x, y: b.position.y - center.y });
        if(state.forceOuterOn){ Body.applyForce(b, b.position, Vector.mult(dir, clamp(state.forceOuter,0,0.01))); }
        if(state.forceInnerOn){ Body.applyForce(b, b.position, Vector.mult(dir, -clamp(state.forceInner,0,0.01))); }
      }
    }

    // -------- Mouse & keys --------
    render.canvas.addEventListener('mousedown', (ev)=>{
      // Skip if clicking within panel bounds (rough guard)
      const withinPanel = (ev.clientX <= 12+360+12 && ev.clientY >= 56 && ev.clientY <= window.innerHeight-12);
      if(withinPanel) return;
      const pos = { x: ev.clientX, y: ev.clientY };
      const hit = Query.point(racks, pos)[0];
      if(hit){ selected = hit; return; }
      const b = addRackAt(pos.x, pos.y); if(!b){ console.log('Placering mislykkedes – prøv et andet sted.'); }
    });

    render.canvas.addEventListener('mousemove', (ev)=>{
      const pos = { x: ev.clientX, y: ev.clientY };
      hoverBody = Query.point(racks, pos)[0] || null;
    });

    window.addEventListener('keydown', (e)=>{
      if(['INPUT','TEXTAREA','SELECT'].includes((document.activeElement?.tagName)||'')) return;
      const stepDeg = Number(state.snapStep)||0; const step = toRad(stepDeg>0? stepDeg: 15);
      if(e.key==='q' || e.key==='Q'){ if(selected){ setAngleSnapped(selected, selected.angle - step); if(state.lockRot) Body.setAngularVelocity(selected,0);} }
      if(e.key==='e' || e.key==='E'){ if(selected){ setAngleSnapped(selected, selected.angle + step); if(state.lockRot) Body.setAngularVelocity(selected,0);} }
      if(e.key==='r' || e.key==='R'){ if(selected){ setAngleSnapped(selected, selected.angle + Math.PI/2); if(state.lockRot) Body.setAngularVelocity(selected,0);} }
      if(e.key==='Delete'){ if(selected){ removeRack(selected); } }
      if(e.key==='Escape'){ selected=null; }
      if(e.code==='Space'){ e.preventDefault(); togglePause(); }
      if(e.key==='g' || e.key==='G'){ engine.world.gravity.y = engine.world.gravity.y? 0: 1; }
      if(e.key==='h' || e.key==='H'){ state.panelHidden=!state.panelHidden; applyPanelVisibility(); saveSettings(); }
      if(e.key==='t' || e.key==='T'){ runTests(); }
    });

    // -------- Enforce no-overlap while dragging --------
    Events.on(engine, 'beforeUpdate', ()=>{
      if (!dragState.body) return;
      const b = dragState.body;
      // Mark invalid and prevent illegal move in real-time
      dragState.invalid = violatesRules(b);
      if (dragState.invalid) {
        Body.setPosition(b, dragState.lastPos);
        Body.setVelocity(b, {x:0,y:0});
        Body.setAngularVelocity(b, 0);
      } else {
        dragState.lastPos = Vector.clone(b.position);
        dragState.lastAngle = b.angle;
      }
    });

    // -------- Render overlays --------
    Events.on(engine, 'afterUpdate', ()=>{
      applyRadialForces();
      for(const r of racks) reflectIfOut(r);
    });

    Events.on(render, 'afterRender', ()=>{
      const ctx = render.context;
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0); // reset to CSS pixels
      ctx.scale(PR, PR);

      // Tank outline
      ctx.beginPath(); ctx.arc(center.x, center.y, tankRadiusPx, 0, Math.PI*2); ctx.strokeStyle = '#00bfff'; ctx.lineWidth = 3; ctx.shadowColor='#00bfff66'; ctx.shadowBlur=6; ctx.stroke(); ctx.shadowBlur=0;

      // Core outline
      const coreR = mm2px(state.coreMm/2); if(coreR>0){ ctx.beginPath(); ctx.arc(center.x, center.y, coreR, 0, Math.PI*2); ctx.strokeStyle = '#ff6b6b'; ctx.setLineDash([6,5]); ctx.lineWidth = 2; ctx.stroke(); ctx.setLineDash([]); }

      // Selected highlight (stronger glow)
      if(selected){ const verts = selected.vertices; ctx.beginPath(); ctx.moveTo(verts[0].x, verts[0].y); for(let i=1;i<verts.length;i++) ctx.lineTo(verts[i].x, verts[i].y); ctx.closePath(); ctx.strokeStyle = '#7cc4ff'; ctx.lineWidth = 2; ctx.shadowColor='#7cc4ff80'; ctx.shadowBlur=10; ctx.stroke(); ctx.shadowBlur=0; }
      // Hover highlight (lighter glow)
      if(hoverBody && hoverBody!==selected){ const v2 = hoverBody.vertices; ctx.beginPath(); ctx.moveTo(v2[0].x, v2[0].y); for(let i=1;i<v2.length;i++) ctx.lineTo(v2[i].x, v2[i].y); ctx.closePath(); ctx.strokeStyle = '#a9d8ff'; ctx.lineWidth = 1.5; ctx.shadowColor='#a9d8ff66'; ctx.shadowBlur=6; ctx.stroke(); ctx.shadowBlur=0; }

      // Red fill when current drag is invalid
      if(dragState.body && dragState.invalid){
        const v = dragState.body.vertices; ctx.beginPath(); ctx.moveTo(v[0].x, v[0].y); for(let i=1;i<v.length;i++) ctx.lineTo(v[i].x, v[i].y); ctx.closePath();
        ctx.fillStyle = 'rgba(255, 107, 107, 0.25)';
        ctx.strokeStyle = '#ff6b6b';
        ctx.lineWidth = 2;
        ctx.fill();
        ctx.stroke();
      }

      ctx.restore();
    });

    // -------- HUD & metrics --------
    function updateHUD(){
      hudCount.textContent = String(racks.length);
      const rackAreaMm2 = racks.reduce((s,b)=>{ const d=bodyDimsPx(b); const wmm=px2mm(d.w), hmm=px2mm(d.h); return s + (wmm*hmm); },0);
      const tankAreaMm2 = Math.PI * Math.pow(state.tankMm/2,2) - Math.PI * Math.pow(state.coreMm/2,2);
      const fill = tankAreaMm2>0? (rackAreaMm2/tankAreaMm2*100): 0;
      hudFill.textContent = `${fill.toFixed(1)}%`;
    }
    setInterval(updateHUD, 600);

    // -------- Buttons --------
    el('addRack').onclick = ()=> addRackAt(center.x, center.y);
    el('add10').onclick = ()=>{ let n=0; for(let i=0;i<10;i++){ if(addRackAt(center.x, center.y)) n++; } console.log(`Tilføjet ${n}/10 racks`); };
    el('clearRacks').onclick = ()=> clearRacks();
    el('deleteSelected').onclick = ()=>{ if(selected) removeRack(selected); };
    el('rebuild').onclick = ()=> rebuildTank();
    el('snapAll').onclick = ()=> snapAll();
    el('addWall').onclick = ()=> addRadialWall(state.radialDeg, state.radialThkMm);
    el('clearWalls').onclick = ()=>{ for(const w of radialWalls) Composite.remove(world, w); statics = statics.filter(s=>!radialWalls.includes(s)); radialWalls.length=0; };

    el('saveLayout').onclick = async ()=>{
      const layout = {
        tankMm: state.tankMm, coreMm: state.coreMm, settings: { ...state },
        racks: racks.map(b=>({ x: b.position.x, y: b.position.y, angle: b.angle, B: b.plugin?.mm?.B ?? state.rackB, L: b.plugin?.mm?.L ?? state.rackL })),
        radialWalls: radialWalls.map(w=>({ angle: toDeg(w.angle), thkMm: px2mm(w.bounds.max.x-w.bounds.min.x) }))
      };
      const json = JSON.stringify(layout, null, 2);
      try{ await navigator.clipboard.writeText(json); alert('Layout kopieret til udklipsholder. (Se også konsollen)'); }catch(e){ alert('Kunne ikke kopiere. JSON logges i konsollen.'); }
      console.log('LAYOUT JSON:', json);
    };

    el('loadLayout').onclick = ()=>{
      const txt = prompt('Indsæt layout JSON:'); if(!txt) return;
      try{
        const data = JSON.parse(txt);
        // Restore key settings
        state.tankMm = Number(data.tankMm)||state.tankMm; state.coreMm = Number(data.coreMm)||state.coreMm;
        if(data.settings){ const keep=['tankMm','coreMm']; Object.assign(state, Object.fromEntries(Object.entries(data.settings).filter(([k])=>!keep.includes(k)))); }
        for(const [k,inp] of Object.entries(inputs)){ const v=state[k]; if(inp.type==='checkbox') inp.checked=!!v; else inp.value=v; }
        saveSettings(); resize();
        // Racks
        clearRacks();
        if(Array.isArray(data.racks)){
          for(const r of data.racks){
            const w = mm2px(r.B||state.rackB), h = mm2px(r.L||state.rackL);
            const b = Bodies.rectangle(r.x, r.y, w, h, {
            label:'rack', restitution: state.restRackRack, friction:0.1, frictionStatic:0.5, frictionAir: state.angDamp*0.5,
            chamfer: { radius: Math.min(w,h) * 0.08 },
            render: { fillStyle:'rgba(18,32,54,0.60)', strokeStyle:'#2e4363', lineWidth:1.5, opacity:0.95 }
          });
            Body.setAngle(b, r.angle||0); b.plugin = { mm: { B: r.B||state.rackB, L: r.L||state.rackL } };
            Composite.add(world, b); racks.push(b);
          }
        }
        // Radial walls
        for(const w of radialWalls) Composite.remove(world,w); radialWalls.length=0; statics = statics.filter(s=>s.label!=='radial');
        if(Array.isArray(data.radialWalls)){ for(const rw of data.radialWalls){ addRadialWall(rw.angle||0, rw.thkMm||state.radialThkMm); } }
        applyRestitutionAll(); applyAngularDampingAll(); applyOrientationLockAll();
        alert('Layout indlæst.');
      }catch(err){ alert('Ugyldigt JSON: '+err.message); }
    };

    el('deleteOverlaps').onclick = ()=>{
      const toDelete = collectOverlaps();
      for(const r of toDelete) removeRack(r);
      alert(`Fjernet ${toDelete.length} racks der overlappede/brød regler.`);
    };

    el('runTests').onclick = ()=> runTests();

    function collectOverlaps(){
      const bad = new Set();
      // 1) Outside tank
      for(const r of racks){ if(anyVertexOutsideTank(r, 0.5)) bad.add(r); }
      // 2) Hit statics
      for(const r of racks){ if(bad.has(r)) continue; if(intersectsStatics(r)) bad.add(r); }
      // 3) Overlap each other (AABB + SAT)
      for(let i=0;i<racks.length;i++){
        for(let j=i+1;j<racks.length;j++){
          const A=racks[i], B=racks[j];
          if(Query.region([B], A.bounds).length===0) continue; if(safeCollided(A,B)){ bad.add(A); bad.add(B); }
        }
      }
      return Array.from(bad);
    }

    // -------- Tests --------
    function runTests(){
      const results = [];
      const ok = (name, pass) => results.push([name, !!pass]);

      // Snap test (from spec)
      const prev = state.allowedAngles; state.allowedAngles = '0,90'; const a = snapAngleRad(toRad(70)); ok('Snap 70°→~90°', Math.abs(toDeg(a)-90)<0.01); state.allowedAngles = prev;

      // Collision tests
      const a1 = Bodies.rectangle(0,0,10,10), a2 = Bodies.rectangle(200,200,10,10), a3 = Bodies.rectangle(5,5,10,10);
      ok('Kollision langt væk = false', safeCollided(a1,a2)===false);
      ok('Kollision overlap = true', safeCollided(a1,a3)===true);

      // Reflection sanity (from spec)
      const v={x:-2,y:1}, n={x:1,y:0}, e=0.6; const v2={ x: v.x - (1+e)*(v.x*n.x+v.y*n.y)*n.x, y: v.y - (1+e)*(v.x*n.x+v.y*n.y)*n.y }; ok("Refleksion v'=(1.2,1)", Math.abs(v2.x-1.2)<1e-9 && Math.abs(v2.y-1)<1e-9);

      // NEW: mm↔px conversion roundtrip
      const mm = 123.4; const px = mm2px(mm); ok('mm2px>0', px>0); ok('px2mm(mm2px(x))≈x', Math.abs(px2mm(px)-mm) < 1e-9);

      // NEW: allowedAngles parsing
      state.allowedAngles = '0,45,90'; const testAngles = allowedAnglesList(); ok('allowedAngles parse len=3', testAngles && testAngles.length===3);
      state.allowedAngles = prev;

      const pass = results.filter(r=>r[1]).length; const out = results.map(r=>`${r[1]? '✅':'❌'} ${r[0]}`).join('\n'); console.log(out); alert(`Tests: ${pass}/${results.length} passer.\n\n`+out);
    }

    // -------- Pause / Play --------
    let paused = false;
    function togglePause(){ paused = !paused; if(paused){ Runner.stop(runner); } else { Runner.run(runner, engine); } }

    // -------- Seed demo --------
    setTimeout(()=>{ for(let i=0;i<8;i++) addRackAt(center.x, center.y); }, 50);

  })();
  </script>
</body>
</html>
